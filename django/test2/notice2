模型：细讲
ORM
实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通过简单的配置就可以轻松更换数据库

ORM是“对象-关系-映射”的简称，主要任务是：
    根据对象的类型生成表结构
    将对象、列表的操作，转换为SQL语句
    将SQL查询到的结构转换为对象、列表

这极大的减轻了开发人员的工作量，不需要面对因数据库变更二导致的无效劳动

Django中的模型包含存储数据的字段和约束，对应着数据库中唯一的表

第一步：新建数据库test2
第二步：配置数据库信息setting.py

    DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql', # 引擎兼容三套数据库，这里改成mysql的
        'NAME': 'test2',
        'USER': 'root',
        'PASSWORD': 'XXX',
        'HOST': 'localhost',
        'PORT': '3306',
    }
}

python manage.py inspectdb > booktest/models.py # 使用数据库生成模型类???

第三步：创建应用 python manage.py startapp booktest
第四步：加载应用
    INSTALLED_APPS = (
    ...
    'booktest',
)

第五步：定义模型(核心目的——生成表的字段以及类型)

关系相互访问：
定义两个类
BookInfo
HeroInfo

    book=models.ForeignKey(BookInfo)

hero对象.book
    hero.book_id(=hero.book.id)
book对象.heroinfo_set

# -*- coding:utf8 -*-

from django.db import models

class BookInfo(models.Model):
    btitle=models.CharField(max_length=20)
    bpub_date=models.DateTimeField(db_column='pub_date')
    bread=models.IntegerField(default=0)            # 阅读量
    bcommet=models.IntegerField(null=False)         # 评论量
    isDelete=models.BooleanField(default=False)

    class Meta:                                     # 元选项?
        db_table='bookinfo'


class HeroInfo(models.Model):
    hname=models.CharField(max_length=10)
    hgender=models.BooleanField(default=True)
    hcontent=models.CharField(max_length=1000)      # 描述
    isDelete=models.BooleanField(default=False)
    book=models.ForeignKey(BookInfo)

第六步：迁移，不用再到数据库里操作
python manage.py makemigrations
Migrations for 'booktest':
  0001_initial.py:
    - Create model BookInfo
    - Create model HeroInfo

python manage.py migrate
Operations to perform:
  Synchronize unmigrated apps: staticfiles, messages
  Apply all migrations: admin, contenttypes, sessions, auth, booktest
Synchronizing apps without migrations:
  Creating tables...
    Running deferred SQL...
  Installing custom SQL...
Running migrations:
  No migrations to apply.
要执行的操作:
  同步未迁移应用程序:
  应用所有迁移:
同步应用程序而不迁移:
  正在创建表...
    正在运行延迟的 SQL...
  正在安装自定义 SQL...
正在运行迁移:
  没有要应用的迁移。 ——这时可以看到数据库里创建了许多新表

  ——已经迁移过了???

模型类（即数据库的管理者?）的属性
objects：默认管理器，是Manager类型的对象，用于与数据库交互
    ——充当ORM的角色：操作数据库数据，映射
任何一个模型类都有一个管理器，可以自定义管理器（可以自定义查询集）
管理器Manager

class BookInfoManager(models.Manager):
    """自定义管理器：原始数据查询"""
    def get_queryset(self):
        """重写父类原始数据查询方法"""
        # 在调用父类方法实现查询的基础上再把一些数据过滤掉
        return super(BookInfoManager, self).get_queryset().filter(
            isDelete=False)     # 过滤掉逻辑删除的，更改父类查询集

模型类的创建
    2种方法,给数据库的表添加数据?

查询


